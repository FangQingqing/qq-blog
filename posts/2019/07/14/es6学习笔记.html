<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ES6学习笔记 | 青青子衿的博客</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/qq-blog/favicon.ico">
    <meta name="description" content="记录工作中学到的知识点。">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/qq-blog/assets/css/0.styles.15e1bad7.css" as="style"><link rel="preload" href="/qq-blog/assets/js/app.db93c5ad.js" as="script"><link rel="preload" href="/qq-blog/assets/js/6.cb21b8bc.js" as="script"><link rel="preload" href="/qq-blog/assets/js/8.c026986c.js" as="script"><link rel="prefetch" href="/qq-blog/assets/js/10.522ee9d8.js"><link rel="prefetch" href="/qq-blog/assets/js/11.a1363106.js"><link rel="prefetch" href="/qq-blog/assets/js/12.5bf2b9ed.js"><link rel="prefetch" href="/qq-blog/assets/js/13.24a8f48c.js"><link rel="prefetch" href="/qq-blog/assets/js/14.5d09d6b0.js"><link rel="prefetch" href="/qq-blog/assets/js/15.aa6b6676.js"><link rel="prefetch" href="/qq-blog/assets/js/16.e490b629.js"><link rel="prefetch" href="/qq-blog/assets/js/17.a9227964.js"><link rel="prefetch" href="/qq-blog/assets/js/2.007c0945.js"><link rel="prefetch" href="/qq-blog/assets/js/3.ee4255b4.js"><link rel="prefetch" href="/qq-blog/assets/js/4.0f9a0595.js"><link rel="prefetch" href="/qq-blog/assets/js/5.b57ccb65.js"><link rel="prefetch" href="/qq-blog/assets/js/7.fa886c89.js"><link rel="prefetch" href="/qq-blog/assets/js/9.0a91e439.js">
    <link rel="stylesheet" href="/qq-blog/assets/css/0.styles.15e1bad7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout" data-v-7f2e4136><header class="header-container" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/qq-blog/post-bg.jfif);" data-v-93921ff8 data-v-7f2e4136><nav class="navbar" style="position:absolute;opacity:1;transition:all 0.5s ease-in-out;" data-v-93921ff8><a href="/qq-blog/" class="navbar-link router-link-active">
    我的博客
  </a> <ul class="navbar-links"><li><a href="/qq-blog/" class="router-link-active">
        主页
      </a></li><li><a href="/qq-blog/about/">
        关于
      </a></li><li><a href="/qq-blog/tags/">
        标签分类
      </a></li></ul> <div id="nav-icon"><span></span><span></span><span></span></div></nav> <div class="header-title" data-v-93921ff8 data-v-93921ff8><h1 data-v-93921ff8>ES6学习笔记</h1> <p data-v-93921ff8></p></div></header> <div class="container" data-v-b3fda33c data-v-7f2e4136><main class="main" style="width:60%;" data-v-b3fda33c><div class="post" data-v-b3fda33c data-v-b3fda33c><article class="main-div"><div class="post-content content content__default"><p>2015年发布的ES6语法，直到2018年才正式接触到，这次的发版提供了很多新语法。对于开发来说，还大大地简化了代码量。</p> <h2 id="ecmascript6简介"><a href="#ecmascript6简介" class="header-anchor">#</a> ECMAScript6简介</h2> <h4 id="babel转码器"><a href="#babel转码器" class="header-anchor">#</a> Babel转码器</h4> <ul><li>作用：可以将ES6代码转为ES5代码</li> <li>配置文件：.babelrc 存放在项目的根目录下，用来设置转码规则和插件</li> <li>安装：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install --save-dev babel-preset-lastest (最新规则)
npm install --save-dev babel-preset-react (react规则)
</code></pre></div><h2 id="let和const"><a href="#let和const" class="header-anchor">#</a> let和const</h2> <h4 id="let"><a href="#let" class="header-anchor">#</a> let</h4> <ul><li>声明变量，只在let命令所在的代码块内有效</li> <li>声明的变量一定要在声明后使用，否则报错</li> <li>不允许重复声明变量</li> <li>可以在块级作用域中声明函数，在块级作用域之外不可引用</li></ul> <h4 id="const"><a href="#const" class="header-anchor">#</a> const</h4> <ul><li>只读常量，一旦声明，常量的值不再改变</li> <li>一旦声明立刻初始化，否则会报错。</li> <li>只在声明所在的块级作用域内有效</li> <li>不可重复声明，保证的是变量指向的内存地址不得改动</li></ul> <h2 id="symbol"><a href="#symbol" class="header-anchor">#</a> Symbol</h2> <p>symbol是JS语言的第七种数据类型，表示独一无二的值。更多使用于对象的属性命名，防止属性名的冲突。</p> <p>每一个Symbol值都是不相等的，用于对象的属性名时，就能保证不会出现同名的属性。这个对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> mySymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 第一种写法</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span>mySymbol<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;hello!&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 第二种写法</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>mySymbol<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">&quot;hello!&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 第三种写法</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mySymbol<span class="token punctuation">,</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token string">&quot;hello!&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 以上写法都得到同样结果</span>
a<span class="token punctuation">[</span>mySymbol<span class="token punctuation">]</span> <span class="token comment">// &quot;hello!&quot;</span>
</code></pre></div><p>注意：</p> <ul><li>Symbol值作为对象名时，不能用点运算符</li> <li>在对象内部，使用Symbol值定义属性时，Symbol值必须放在方括号中</li> <li>Symbol值作为属性名时，该属性还是公开属性，不是私有属性</li> <li>Symbol作为属性名，遍历对象的时候，该属性不会出现在for...in，for...of循环中，也不会被Object.keys()，Object.getOwnPropertyNames()，JSON.stringify()返回</li></ul> <h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="header-anchor">#</a> 变量的解构赋值</h2> <h4 id="数组的解构赋值"><a href="#数组的解构赋值" class="header-anchor">#</a> 数组的解构赋值</h4> <ul><li>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="header-anchor">#</a> 对象的解构赋值</h4> <ul><li>变量必须与属性同名</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>foo<span class="token operator">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span> bar<span class="token operator">:</span> <span class="token string">'bbb'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>内部机制：先找到同名属性，然后再赋值给对应的变量，真正被赋值的是后者，而不是前者</li> <li>对象的解构赋值也可以指定默认值，生效的前提是对象的属性值严格等于undefined</li></ul> <h4 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="header-anchor">#</a> 字符串的解构赋值</h4> <ul><li>字符串此时被转换成了一个类似数组的对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="header-anchor">#</a> 数值和布尔值的解构赋值</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">{</span>toString<span class="token operator">:</span> s<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span>toString<span class="token operator">:</span> s<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li></ul> <h4 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="header-anchor">#</a> 函数参数的解构赋值</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
</code></pre></div><h4 id="不使用圆括号的情况"><a href="#不使用圆括号的情况" class="header-anchor">#</a> 不使用圆括号的情况</h4> <ul><li>变量声明语句</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>函数参数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>赋值语句的模式</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token punctuation">{</span>p<span class="token operator">:</span> a<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{</span>p<span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>可以使用圆括号的情况：赋值语句的非模式部分</li></ul> <h4 id="用途"><a href="#用途" class="header-anchor">#</a> 用途</h4> <ul><li>变换变量的值</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>y<span class="token punctuation">,</span> x<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>从函数返回多个值</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>函数参数的定义</li> <li>提取JSON数据</li> <li>函数参数的默认值</li> <li>遍历Map结构</li> <li>输入模块的指定方法</li></ul> <h2 id="字符串的扩展"><a href="#字符串的扩展" class="header-anchor">#</a> 字符串的扩展</h2> <ul><li>字符的Unicode表示法：'\uxxxx'</li> <li>codePointAt()：能够正确处理4个字节储存的字符，返回一个字符的码点</li> <li>String.fromCodePoint()：用于从码点返回对应字符</li> <li>字符串的遍历器接口：for...of</li> <li>at()：返回字符串给定位置的字符</li> <li>includes()：返回布尔值，表示是否找到参数字符串</li> <li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部</li> <li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部</li> <li>repeat()：返回新字符串，表示将原字符值重复n次</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">'x'</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'xxx'</span>
</code></pre></div><h2 id="数值的扩展"><a href="#数值的扩展" class="header-anchor">#</a> 数值的扩展</h2> <ul><li>二进制表示：前缀0b or 0B，八进制表示：前缀0o or 0O</li> <li>Number.isFinite()：判断数值是否为有限的，非数值一律返回false</li> <li>Number.isNaN()：只有对NaN才返回true，非NaN一律返回false</li> <li>Number.parseInt(), Number.parseFloat()</li> <li>Number.isInteger()：判断一个值是否为整数</li> <li>Number.EPSILON：极小常数  2.220446049250313e-16</li> <li>Number.isSafeInteger()：判断一个整数是否在安全范围内</li></ul> <div class="language- extra-class"><pre class="language-text"><code>整数范围：-2^53 - 2^53
最大值: Number.MAX_SAFE_INTEGER
最小值: Number.MIN_SAFE_INTEGER
</code></pre></div><ul><li>Math对象的扩展</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Math.trunc()：除一个数的小数部分，返回整数部分
Math.sign()：判断一个数到底是正数(+1),负数(-1),零(+0,-0),还是其他值(NaN)
Math.cbrt()：计算一个数的立方根
Math.clz32()：返回一个数的32位无符号整数形式有多少个前导0
Math.imul()：返回两个数以32位带符号整数形式相乘的结果
Math.hypot()：返回所有参数的平方和的平方根
</code></pre></div><ul><li>指数运算符：**</li> <li>对数方法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Math.expml()：e^x - 1
Math.log1p()：Math.log(1 + x), x小于-1返回NaN
Math.log1o()：Math.log2(x), x小于0返回NaN
</code></pre></div><ul><li>Integer数据类型</li></ul> <div class="language- extra-class"><pre class="language-text"><code>运算：几乎所有的Number运算符都可以用在Integer
Integer类型不能与Number类型进行混合运算
双等==不可以混合运算，全等===可以混合运算
</code></pre></div><h2 id="函数的扩展"><a href="#函数的扩展" class="header-anchor">#</a> 函数的扩展</h2> <ul><li>rest参数：形式为...变量名，用于获取函数的多余参数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>注意：
rest参数之后不能再有其他参数
函数的length(计算函数参数个数)属性，不包括rest参数
</code></pre></div><ul><li>严格模式：只要函数参数使用了默认值，解构赋值或者扩展运算符，就不能设定为严格模式</li></ul> <div class="language- extra-class"><pre class="language-text"><code>规避这种限制：
1.设定全局的严格模式
2.把函数包在一个无参数的立即执行函数里面
</code></pre></div><ul><li>name属性：返回该函数的函数名</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Function构造函数返回的函数实例，name属性的值为anonymous
bind返回的函数，name属性值会加上bind前缀
function foo() {}; foo.bind({}).name
</code></pre></div><ul><li>箭头函数：ES6允许使用箭头(=&gt;)定义函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token parameter">v</span> <span class="token operator">=&gt;</span> v<span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象</span>
</code></pre></div><ul><li>绑定this：函数绑定运算符是并排两个冒号(:😃,双冒号左边是一个对象，右边是一个函数</li></ul> <h2 id="数组的扩展"><a href="#数组的扩展" class="header-anchor">#</a> 数组的扩展</h2> <ul><li>扩展运算符：(...) 可以展开数组</li></ul> <div class="language- extra-class"><pre class="language-text"><code>应用：
合并数组：[1, 2, ...more]
与解构赋值结合：const [first, ...rest] = [1, 2, 3, 4, 5]
函数返回值：可以返回多个值
字符串：[...'hello'] // ['h', 'e', 'l', 'l', 'o']
</code></pre></div><ul><li>Array.from()：用于将两类对象转为真正的数组</li> <li>Array.of()：用于将一组值转换为数组</li> <li>数组实例的copyWithin()：在当前数组内部，将指定位置的成员复制到其他位置；接收三个参数：target(起始位置开始替换)，start(从该位置开始读取数据)，end(到该位置前停止读取数据)</li> <li>数组实例的find()和findIndex()：找出第一个符合条件的数组成员和他所在位置</li> <li>fill()：用给定值填充一个数组，常用于空数组初始化</li> <li>keys()：对键名的遍历</li> <li>values()：对键值的遍历</li> <li>entries()：对键值对的遍历</li> <li>includes()：返回布尔值，表示某个数组是否包含给定的值</li></ul> <h2 id="对象的扩展"><a href="#对象的扩展" class="header-anchor">#</a> 对象的扩展</h2> <ul><li>object.is()：用来比较两个值是否严格相等</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 不同之处：+0 != -0, NaN等于自身</span>
<span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span> <span class="token comment">// true</span>
<span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span> <span class="token comment">// false</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><ul><li>Object.assign()：用于对象的合并</li></ul> <div class="language- extra-class"><pre class="language-text"><code>为对象添加属性和方法
克隆对象
合并多个对象
为属性指定默认值
</code></pre></div><ul><li>keys(), values(), entries()</li> <li>Object.getPropertyDescriptors()：返回某个对象属性的描述对象</li> <li>Null传导运算符：?. 只要其中一个返回null或undefined，就不再往下运算，而是返回undefined</li></ul> <div class="language- extra-class"><pre class="language-text"><code>obj?.prop or obj?.expr // 读取对象属性
func?.(...args) //函数或对象方法的调用
new C?.(...args) //构造函数的调用
</code></pre></div><ul><li>Symbol：原始数据类型(独一无二，防止对象的属性重名)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">typeof</span> s <span class="token comment">// symbol</span>
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Symbol值不能与其他类型进行运算，但可以显示转为字符串和布尔值，但不能转为数组
属性名的遍历：Object.getOwnPropertySymbols()返回一个数组，成员是当前对象的所有用作属性名的symbol值
Symbol.for()：判断有没有这个值，有返回这个值，没有返回一个新的Symbol值
Symbol.keyFor()：返回一个已登记的Symbol类型值的key
</code></pre></div><h2 id="set数据结构"><a href="#set数据结构" class="header-anchor">#</a> Set数据结构</h2> <ul><li>类似数组，成员值唯一</li> <li>在Set内部，两个NaN相等，而两个对象不相等</li> <li>实例属性：Set.prototype.constructor:构造函数，默认是Set函数；Set.prototype.size():返回Set实例的成员总数</li> <li>操作方法：add(value),delete(value),has(value),clear()</li> <li>遍历操作：keys(),values(),entries(),forEach()</li></ul> <h2 id="weakset数据结构"><a href="#weakset数据结构" class="header-anchor">#</a> WeakSet数据结构</h2> <ul><li>成员值唯一，但成员只能是对象(弱引用，不使用时回收)，成员个数不确定，不可遍历</li> <li>方法：WeakSet.prototype.add(value), WeakSet.prototype.delete(value), WeakSet.prototype.has(value)</li> <li>用途：存储DOM节点，不用担心DOM节点从文档移除时，引发内存泄漏</li></ul> <h2 id="map数据结构"><a href="#map数据结构" class="header-anchor">#</a> Map数据结构</h2> <ul><li>类似对象(键值对集合)，键的范围不限于字符串，各种类型的值都可以当作键</li> <li>属性：size(返回Map结构的成员总数)</li> <li>方法：set(key, value)：设置键名和对应值;</li> <li>get(key)：取key对应的值;</li> <li>has(key)</li> <li>delete(key)</li> <li>clear()</li> <li>遍历方法：keys(), values(), entries(), forEach()</li></ul> <h2 id="weakmap数据结构"><a href="#weakmap数据结构" class="header-anchor">#</a> WeakMap数据结构</h2> <ul><li>用于生成键值对的集合</li> <li>与Map区别：1.只接受对象作为键名(null除外), 2.WeakMap的键名所指向对象不计入垃圾回收机制</li> <li>应用：在网页的DOM元素上添加数据</li> <li>方法：get(), set(), has(), delete()</li></ul> <h2 id="proxy"><a href="#proxy" class="header-anchor">#</a> Proxy</h2> <ul><li>用于修改某些操作的默认行为</li> <li>方法：get(): 拦截读取操作;</li> <li>set(): 拦截赋值操作;</li> <li>apply(): 拦截函数的调用;</li> <li>has(): 拦截hasProperty操作;</li> <li>construct(): 拦截new命令;</li> <li>deleteProperty(), defineProperty(), getOwnPropertyDescriptor(), getPrototypeof()</li></ul> <h2 id="reflect"><a href="#reflect" class="header-anchor">#</a> Reflect</h2> <ul><li>将object对象一些明显属于语言内部方法放到Reflect对象上</li> <li>修改某些object方法的返回结果，让其变得合理</li> <li>让object操作都变成函数行为</li> <li>Reflect对象的方法与Proxy对象的方法一一对应</li></ul> <h2 id="promise对象"><a href="#promise对象" class="header-anchor">#</a> Promise对象</h2> <ul><li>是异步编程的一种解决方案</li> <li>是一个容器，里面保存着某个未来才会结束的事件</li> <li>是一个对象，从它可以获取异步操作的消息</li> <li>特点：对象的状态不受外界影响(pending, fulfilled, rejected), 一旦状态改变，就不会再变</li> <li>创造Promise实例</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment">/* 异步操作成功 */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// resolve函数作用：将Promise对象的状态从“未完成”变成“成功”</span>
<span class="token comment">// reject函数作用：将Promise对象的状态从“未完成”变成“失败”</span>
<span class="token comment">// Promise新建后立即执行</span>
</code></pre></div><ul><li>方法：Promise.prototype.then():为Promise实例添加状态改变时的回调函数，Promise.prototype.catch():用于指定发生错误时的回调函数，Promise.all():将多个Promise实例包装成一个新的Promise实例</li></ul> <h2 id="iterator-和-for-of循环"><a href="#iterator-和-for-of循环" class="header-anchor">#</a> Iterator 和 for...of循环</h2> <ul><li>Iterator概念：遍历器，接口，为不同数据结构提供统一的访问机制，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”</li> <li>原生具备Iterator接口的数据结构如下：Array, Map, Set, string, TypedArray, 函数的arguments对象</li> <li>方法：next():返回value和done，必须部署，return(),throw()：可选部署</li> <li>for...of循环：使用范围：Set, Map, arguments对象, DOM, NodeList对象, Generator对象, 字符串, 数组</li> <li>for...in缺点：数组的键名是数字，for...in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型键上的值，某些情况下，for...in循环会以任意 顺序遍历键名</li> <li>for...of优点：有着同for...in一样简洁语法，但是没有for...in那些缺点；不同于forEach方法，他可以与break, continue和return配合使用；提供了遍历所有数据结构的统一操作接口</li></ul> <h2 id="generator函数"><a href="#generator函数" class="header-anchor">#</a> Generator函数</h2> <ul><li>概念：提供一种异步编程解决方案，返回遍历器对象</li> <li>特征：function关键字与函数名之间有一个星号(*), 函数内部使用yield表达式；</li> <li>Generator函数分段执行，yield表达式是暂停执行标记，next方法可以恢复执行</li> <li>yield表达式只能用在Generator函数内部，用在其他地方会报错</li> <li>yield表达式如果用在另一个表达式中，必须放在圆括号里面</li> <li>next方法的参数：表示上一个yield表达式的返回值</li> <li>for...of循环：一旦next方法的返回对象的done属性为true，循环就会终止</li> <li>应用：异步操作的同步化表达，控制流管理，部署Iterator接口，作为数据结构</li></ul> <h2 id="generator函数的异步应用"><a href="#generator函数的异步应用" class="header-anchor">#</a> Generator函数的异步应用</h2> <ul><li>协程：多个线程互相协作，完成异步任务；协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行</li> <li>Thunk函数：自动执行Generator函数的一种方法，是传名调用(只在执行时求值)的一种实现策略，用来替换某个表达式</li></ul> <h2 id="aync函数"><a href="#aync函数" class="header-anchor">#</a> aync函数</h2> <ul><li>是Generator函数的语法糖</li> <li>区别：* =&gt; async, yield =&gt; await</li> <li>改进：内置执行器；更好的语义；更广的适用性；返回值是Promise</li> <li>用法：async函数返回一个Promise对象，可以使用then方法添加回调函数</li> <li>async函数内部return语句返回的值，会成为then方法回调函数的参数</li> <li>正常情况下，await命令后面是一个Promise对象，如果不是，会被转成一个立即resolve的Promise对象</li> <li>await命令后面的Promise对象如果变成reject状态，则reject的参数会被catch方法的回调函数接收到</li> <li>只要一个await语句后面的Promise变成reject，那么async函数都会中断执行；</li> <li>防止出错的方法，将其放在try...catch代码块中，await命令放在try...catch代码块中；</li> <li>异步遍历器：next方法返回的value和done异步产生</li></ul> <h2 id="class的基本语法"><a href="#class的基本语法" class="header-anchor">#</a> class的基本语法</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">','</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token comment">// 定义类不需要加function，方法之间不需要逗号分隔</span>
</code></pre></div><ul><li>类的内部定义的方法都是不可枚举的</li> <li>类的属性名可以采用表达式</li> <li>类和模块内部默认就是严格模式</li> <li>constructor是类的默认方法</li> <li>ES6不提供私有方法和属性，解决：加#</li> <li>class的静态方法，前面加static，实例不能继承，只能通过类调用</li> <li>父类静态方法可以被子类继承</li> <li>new.target属性：如果构造函数不是通过new命令调用，new.target返回undefined</li></ul> <h2 id="class的继承"><a href="#class的继承" class="header-anchor">#</a> class的继承</h2> <ul><li>使用extends关键字，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">colorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// super方法：表示父类的构造函数，必须在constructor中才能调用（任何一个类都有constructor方法）</span>
<span class="token comment">// ES6继承机制：先创建父类实例对象this，再用子类的构造函数修改this</span>
</code></pre></div><ul><li>object.getPrototypeof(): 用来从子类上获取父类</li> <li>类的prototype和_proto_属性，子类的_proto_属性表示构造函数的继承，总是指向父类，子类prototype属性的_proto_属性表示方法的继承，总是指向父类的prototype属性</li></ul> <h2 id="decorator修饰器"><a href="#decorator修饰器" class="header-anchor">#</a> Decorator修饰器</h2> <ul><li>Decorator是一个函数，用来修改类的行为</li> <li>修饰器对类的行为的改变，是代码编译时发生的，不是在运行时</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">testable</span> <span class="token punctuation">(</span><span class="token parameter">target</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isTestable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
@testable
<span class="token keyword">class</span> <span class="token class-name">MyTestableClass</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTestableClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>isTestable <span class="token comment">// true</span>
</code></pre></div><ul><li>修饰器只能用于类和类的方法，修饰器有注释作用，从外到内进入，从内到外执行</li> <li>第三方模块：core-decorator.js; @autobind: 使方法中的this对象绑定原始对象；@readonly: 使属性或方法不可写</li> <li>Minxin模式(混入)：在一个对象中混入另一个对象的方法</li></ul> <h2 id="module语法"><a href="#module语法" class="header-anchor">#</a> Module语法</h2> <ul><li>模块功能：import(输入其他模块提供的功能)，export(模块对外接口，可以输出变量，函数和类)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> firstName <span class="token operator">=</span> <span class="token string">&quot;Michael&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> lastName <span class="token operator">=</span> <span class="token string">&quot;Jackson&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> year <span class="token operator">=</span> <span class="token number">1994</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>
  firstName<span class="token punctuation">,</span>
  lastName<span class="token punctuation">,</span>
  year
<span class="token punctuation">}</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>
  firstName<span class="token punctuation">,</span>
  lastName<span class="token punctuation">,</span>
  year
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./profile&quot;</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>export default: 为模块制定默认输出，该命令只能使用一次（本质：输出一个叫做default的变量或方法，然后系统允许你为他取任意名字）</li> <li>import和export命令只能在模块的顶层</li> <li>import()函数：实现动态加载功能；使用场合：按需加载，条件加载，动态的模块路径</li> <li>import()加载模块成功后，这个模块作为对象当作then方法的参数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;./myModule.js&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>export1<span class="token punctuation">,</span> export2<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>脚本实现异步加载，defer:渲染完再执行；async:下载完就执行</li> <li>ES6脚本加载模块：type=&quot;module&quot; 默认defer加载</li></ul></div></article> <!----></div></main> <aside class="aside" data-v-b3fda33c data-v-b3fda33c><div class="info-card main-div" data-v-1311ce9e data-v-b3fda33c><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/qq-blog/avatar-bg.jfif);" data-v-1311ce9e><img src="/qq-blog/avatar.jpeg" alt="青青子衿" class="info-avatar" data-v-1311ce9e></div> <div class="info-card-body" data-v-1311ce9e><section class="info-name" data-v-1311ce9e>
      青青子衿
    </section> <section class="info-desc" data-v-1311ce9e>一枚程序媛，爱工作，爱生活！</section> <section class="info-contact" data-v-1311ce9e><section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-location" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          重庆 渝北
        </span></span></section> <!----> <section data-v-1311ce9e><span data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:1em;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-email" data-v-1311ce9e data-v-1311ce9e></use></svg><span class="info-text" data-v-1311ce9e data-v-1311ce9e>
          1350221123@qq.com
        </span></span></section></section></div> <div class="info-card-footer" data-v-1311ce9e><p class="footer-sns-link" data-v-1311ce9e><a target="_blank" href="https://github.com/FangQingqing" class="sns-link" data-v-1311ce9e><span class="sns-icon" data-v-1311ce9e data-v-1311ce9e><svg class="icon" style="font-size:35px;" data-v-1311ce9e data-v-1311ce9e><use xlink:href="#icon-github" data-v-1311ce9e data-v-1311ce9e></use></svg></span></a></p></div></div> <div class="post-toc main-div aside-toc" style="position:relative;top:0;width:0px;" data-v-b3fda33c><h4>- CATALOG</h4> <div class="post-nav-toc"><ul><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#ecmascript6简介">ECMAScript6简介</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#let和const">let和const</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#symbol">Symbol</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#变量的解构赋值">变量的解构赋值</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#字符串的扩展">字符串的扩展</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#数值的扩展">数值的扩展</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#函数的扩展">函数的扩展</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#数组的扩展">数组的扩展</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#对象的扩展">对象的扩展</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#set数据结构">Set数据结构</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#weakset数据结构">WeakSet数据结构</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#map数据结构">Map数据结构</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#weakmap数据结构">WeakMap数据结构</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#proxy">Proxy</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#reflect">Reflect</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#promise对象">Promise对象</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#iterator-和-for-of循环">Iterator 和 for...of循环</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#generator函数">Generator函数</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#generator函数的异步应用">Generator函数的异步应用</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#aync函数">aync函数</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#class的基本语法">class的基本语法</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#class的继承">class的继承</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#decorator修饰器">Decorator修饰器</a></li><li><a href="/qq-blog/posts/2019/07/14/es6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#module语法">Module语法</a></li></ul></div></div></aside></div> <footer class="footer" data-v-7f2e4136><p class="footer-sns-link"><a target="_blank" href="https://github.com/FangQingqing" class="sns-link"><span class="sns-icon"><svg class="icon" style="font-size:40px;"><use xlink:href="#icon-github"></use></svg></span></a></p> <div class="copyright"><span id="custom"></span> <!----></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/qq-blog/assets/js/app.db93c5ad.js" defer></script><script src="/qq-blog/assets/js/6.cb21b8bc.js" defer></script><script src="/qq-blog/assets/js/8.c026986c.js" defer></script>
  </body>
</html>
